from dotenv import load_dotenv
import os
import re
import requests
import pathlib

script_path = pathlib.Path(__file__).resolve()
env_path = script_path.parent.parent / ".env"
if env_path.exists():
    print(f"Loading {env_path}, which needs to contain GITHUB_TOKEN.")
    loading_worked = load_dotenv(env_path, override=True)
    if not loading_worked:
        raise Exception(f"{env_path} does not contain any environment variables.")
else:
    print(f"Dotenv file not found under {env_path}, hopefully the GITHUB_TOKEN is contained in the global environment.")

# GitHub repository details
owner = "ossf"
repo = "scorecard"
url = f"https://api.github.com/repos/{owner}/{repo}/git/trees/main?recursive=1"

# Headers required by GitHub API
headers = {
    "User-Agent": "Python-Directory-Fetcher"
}
github_pat = os.getenv("GITHUB_TOKEN")
if github_pat:
    last_5 = github_pat[-4:]
    print(f"Using GITHUB_TOKEN token ***{last_5}.")
    headers["Authorization"] = f"Bearer {github_pat}"
else:
    raise Exception("No variable called GITHUB_TOKEN was found in the environment.")

script_dir = os.path.dirname(os.path.abspath(__file__))
TARGET_PATH = os.path.join(script_dir, "..", "src", "probe_name.rs")

TEMPLATE = """
/// This file is generated by scripts/generate_code.py
/// Please do not modify it directly.

use std::fmt::Display;

use serde::{{Deserialize, Serialize}};

#[derive(Deserialize, Serialize, Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(non_camel_case_types)]
pub(crate) enum ProbeName {{
    {probes}
}}

impl ProbeName {{
    pub(crate) fn as_str(&self) -> &'static str {{
        match self {{
            {as_str}
        }}
    }}

    pub(crate) fn get_description(&self) -> &'static str {{
        match self {{
            {descriptions}
        }}
    }}
}}

impl Display for ProbeName {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        write!(f, "{{}}", self.as_str())
    }}
}}

#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn display_is_as_expected() {{
        assert_eq!(ProbeName::archived.to_string(), "archived");
    }}
}}
"""

AS_STR_TEMPLATE = "ProbeName::{probe} => \"{probe}\""
DESCRIPTION_TEMPLATE = "ProbeName::{probe} => \"{description}\""

def get_probes():
    try:
        # Send a GET request to GitHub API
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Raise error for HTTP issues
        contents = response.json()
        filepaths = [item['path'] for item in contents['tree']]

        pattern = r"probes/([^/]+)/def\.yml"
        probes = [match.group(1) for filepath in filepaths if (match := re.search(pattern, filepath))]
        num_probes = len(probes)

        print(f"Found {num_probes} probes.")
        
        return probes
    except requests.exceptions.RequestException as e:
        print(f"\nError: {e}\n")
        raise

def get_as_str_parts(probes):
    return [AS_STR_TEMPLATE.format(probe = probe) for probe in probes]

def get_description_parts(probes):
    return [DESCRIPTION_TEMPLATE.format(probe = probe, description = probe) for probe in probes]

probes = get_probes()
as_str_parts = get_as_str_parts(probes)
description_parts = get_description_parts(probes)
with open(TARGET_PATH, 'w') as file:
    file.write(TEMPLATE.format(probes = ",".join(probes),
                               as_str = ",".join(as_str_parts),
                               descriptions = ",".join(description_parts)))