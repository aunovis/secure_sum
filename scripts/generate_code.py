from dotenv import load_dotenv
import os
import re
import requests
import pathlib
import yaml

script_path = pathlib.Path(__file__).resolve()
env_path = script_path.parent.parent / ".env"
if env_path.exists():
    print(f"Loading {env_path}, which needs to contain GITHUB_TOKEN.")
    loading_worked = load_dotenv(env_path, override=True)
    if not loading_worked:
        raise Exception(f"{env_path} does not contain any environment variables.")
else:
    print(f"Dotenv file not found under {env_path}, hopefully the GITHUB_TOKEN is contained in the global environment.")

# GitHub repository details
owner = "ossf"
repo = "scorecard"
url = f"https://api.github.com/repos/{owner}/{repo}/git/trees/main?recursive=1"

# Headers required by GitHub API
headers = {
    "User-Agent": "Python-Directory-Fetcher"
}
github_pat = os.getenv("GITHUB_TOKEN")
if github_pat:
    last_5 = github_pat[-4:]
    print(f"Using GITHUB_TOKEN token ***{last_5}.")
    headers["Authorization"] = f"Bearer {github_pat}"
else:
    raise Exception("No variable called GITHUB_TOKEN was found in the environment.")

script_dir = os.path.dirname(os.path.abspath(__file__))
TARGET_PATH = os.path.join(script_dir, "..", "src", "probe_name.rs")

TEMPLATE = """
/// This file is generated by scripts/generate_code.py
/// Please do not modify it directly.

use std::fmt::Display;

use serde::{{Deserialize, Serialize}};

#[derive(Deserialize, Serialize, Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[allow(non_camel_case_types)]
pub(crate) enum ProbeName {{
    {probes}
}}

impl ProbeName {{
    pub(crate) fn as_str(&self) -> &'static str {{
        match self {{
            {as_str}
        }}
    }}

    pub(crate) fn get_description(&self) -> &'static str {{
        match self {{
            {descriptions}
        }}
    }}
}}

impl Display for ProbeName {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        write!(f, "{{}}", self.as_str())
    }}
}}

#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn display_is_as_expected() {{
        assert_eq!(ProbeName::archived.to_string(), "archived");
    }}
}}
"""

AS_STR_TEMPLATE = "ProbeName::{probe_id} => \"{probe_id}\""
DESCRIPTION_TEMPLATE = "ProbeName::{probe_id} => \"{description}\""

def get_probes():
    try:
        # Send a GET request to GitHub API
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Raise error for HTTP issues
        contents = response.json()
        filepaths = [item['path'] for item in contents['tree']]

        pattern = r"probes/([^/]+)/def\.yml"
        yml_filepaths = [filepath for filepath in filepaths if re.search(pattern, filepath)]

        file_urls = [f"https://raw.githubusercontent.com/{owner}/{repo}/main/{filepath}" for filepath in yml_filepaths]
        probes = {}
        for file_url in file_urls:
            res = requests.get(file_url, headers=headers)
            res.raise_for_status()
            file_content = yaml.load(res.text, Loader=yaml.SafeLoader)
            motivation = file_content['motivation'].strip().replace('\"', '\'')
            implementation = file_content['implementation'].strip().replace('\"', '\'')
            probes[file_content['id']] = f"motivation: {motivation}\\nimplementation: {implementation}"

        num_probes = len(probes)
        print(f"Found {num_probes} probes.")
        
        return probes
    except requests.exceptions.RequestException as e:
        print(f"\nError: {e}\n")
        raise

def get_as_str_parts(probe_ids):
    return [AS_STR_TEMPLATE.format(probe_id = id) for id in probe_ids]

def get_description_parts(probes):
    return [DESCRIPTION_TEMPLATE.format(probe_id = id, description = description) for (id, description) in probes.items()]

probes = get_probes()
as_str_parts = get_as_str_parts(probes.keys())
description_parts = get_description_parts(probes)
with open(TARGET_PATH, 'w') as file:
    file.write(TEMPLATE.format(probes = ",".join(probes.keys()),
                               as_str = ",".join(as_str_parts),
                               descriptions = ",".join(description_parts)))